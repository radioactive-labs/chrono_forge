[
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/CHANGELOG.md",
    "contents": "## [Unreleased]\n\n## [0.1.0] - 2024-12-21\n\n- Initial release\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/README.md",
    "contents": "# ChronoForge\n\nChronoForge is a Ruby gem that provides a robust framework for building durable, distributed workflows in Ruby on Rails applications. It offers a reliable way to handle long-running processes, state management, and error recovery.\n\n## Features\n\n- **Durable Execution**: Automatically tracks and recovers from failures during workflow execution\n- **State Management**: Built-in workflow state tracking with support for custom contexts\n- **Concurrency Control**: Advanced locking mechanisms to prevent concurrent execution of the same workflow\n- **Error Handling**: Comprehensive error tracking and retry strategies\n- **Execution Logging**: Detailed logging of workflow execution steps and errors\n- **Wait States**: Support for time-based waits and condition-based waiting\n- **Database-Backed**: All workflow state is persisted to the database for durability\n- **ActiveJob Integration**: Seamlessly works with any ActiveJob backend\n\n## Installation\n\nAdd this line to your application's Gemfile:\n\n```ruby\ngem 'chrono_forge'\n```\n\nThen execute:\n\n```bash\n$ bundle install\n```\n\nOr install it directly:\n\n```bash\n$ gem install chrono_forge\n```\n\nAfter installation, run the generator to create the necessary database migrations:\n\n```bash\n$ rails generate chrono_forge:install\n$ rails db:migrate\n```\n\n## Usage\n\n### Basic Workflow Example\n\nHere's a complete example of a durable order processing workflow:\n\n```ruby\nclass OrderProcessingWorkflow < ApplicationJob\n  include ChronoForge::Executor\n\n  def perform\n    # Context can be used to pass and store data between executions\n    context[\"order_id\"] = SecureRandom.hex\n\n    # Wait until payment is confirmed\n    wait_until :payment_confirmed?\n\n    # Wait for potential fraud check\n    wait 1.minute, :fraud_check_delay\n\n    # Durably execute order processing\n    durably_execute :process_order\n\n    # Final steps\n    complete_order\n  end\n\n  private\n\n  def payment_confirmed?\n    PaymentService.confirmed?(context[\"order_id\"])\n  end\n\n  def process_order\n    context[\"processed_at\"] = Time.current.iso8601\n    OrderProcessor.process(context[\"order_id\"])\n  end\n\n  def complete_order\n    context[\"completed_at\"] = Time.current.iso8601\n    OrderCompletionService.complete(context[\"order_id\"])\n  end\nend\n```\n\n### Workflow Features\n\n#### Durable Execution\n\nThe `durably_execute` method ensures operations are executed exactly once:\n\n```ruby\n# Execute a method\ndurably_execute(:process_payment, max_attempts: 3)\n\n# Or with a block\ndurably_execute -> (ctx) {\n  Payment.process(ctx[:payment_id])\n}\n```\n\n#### Wait States\n\nChronoForge supports both time-based and condition-based waits:\n\n```ruby\n# Wait for a specific duration\nwait 1.hour, :cooling_period\n\n# Wait until a condition is met\nwait_until :payment_processed, \n  timeout: 1.hour,\n  check_interval: 5.minutes\n```\n\n#### Workflow Context\n\nChronoForge provides a persistent context that survives job restarts:\n\n```ruby\n# Set context values\ncontext[:user_name] = \"John Doe\"\ncontext[:status] = \"processing\"\n\n# Read context values\nuser_name = context[:user_name]\n```\n\n### Error Handling\n\nChronoForge automatically tracks errors and provides retry capabilities:\n\n```ruby\nclass MyWorkflow < ApplicationJob\n  include ChronoForge::Executor\n\n  private\n\n  def should_retry?(error, attempt_count)\n    case error\n    when NetworkError\n      attempt_count < 5\n    when ValidationError\n      false  # Don't retry validation errors\n    else\n      attempt_count < 3\n    end\n  end\nend\n```\n\n### Cleanup\n\nChronoForge includes built-in cleanup methods for managing old workflow data:\n\n```ruby\n# Clean up old workflows and logs\nChronoForge::Workflow.cleanup_old_logs(retention_period: 30.days)\nChronoForge::ExecutionLog.cleanup_old_logs(retention_period: 30.days)\nChronoForge::ErrorLog.cleanup_old_logs(retention_period: 30.days)\n```\n\n## Testing\n\nChronoForge is designed to be easily testable using [ChaoticJob](https://github.com/fractaledmind/chaotic_job), a testing framework that makes it simple to test complex job workflows. Here's how to set up your test environment:\n\n1. Add ChaoticJob to your Gemfile's test group:\n\n```ruby\ngroup :test do\n  gem 'chaotic_job'\nend\n```\n\n2. Set up your test helper:\n\n```ruby\n# test_helper.rb\nrequire 'chrono_forge'\nrequire 'minitest/autorun'\nrequire 'chaotic_job'\n```\n\nExample test:\n\n```ruby\nclass WorkflowTest < Minitest::Test\n  include ChaoticJob::Helpers\n\n  def test_workflow_completion\n    # Enqueue the job\n    OrderProcessingWorkflow.perform_later(\"order_123\")\n    \n    # Perform all enqueued jobs\n    perform_all_jobs\n    \n    # Assert workflow completed successfully\n    workflow = ChronoForge::Workflow.last\n    assert workflow.completed?\n    \n    # Check workflow context\n    assert workflow.context[\"processed_at\"].present?\n    assert workflow.context[\"completed_at\"].present?\n  end\nend\n```\n\nChaoticJob provides several helpful methods for testing workflows:\n\n- `perform_all_jobs`: Processes all enqueued jobs, including those enqueued during job execution\n- `enqueued_jobs`: Returns the current number of jobs in the queue\n\nFor testing with specific job processing libraries like Sidekiq or Delayed Job, you can still use their respective testing modes, but ChaoticJob is recommended for testing ChronoForge workflows as it better handles the complexities of nested job scheduling and wait states.\n\n\n## Database Schema\n\nChronoForge creates three main tables:\n\n1. `chrono_forge_workflows`: Stores workflow state and context\n2. `chrono_forge_execution_logs`: Tracks individual execution steps\n3. `chrono_forge_error_logs`: Records detailed error information\n\n## Development\n\nAfter checking out the repo, run:\n\n```bash\n$ bin/setup                 # Install dependencies\n$ bundle exec rake test     # Run the tests\n$ bin/appraise              # Run the full suite of appraisals\n$ bin/console               # Start an interactive console\n```\n\nThe test suite uses SQLite by default and includes:\n- Unit tests for core functionality\n- Integration tests with ActiveJob\n- Example workflow implementations\n\n## Contributing\n\n1. Fork the repository\n2. Create your feature branch (`git checkout -b feature/my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin feature/my-new-feature`)\n5. Create a new Pull Request\n\nPlease include tests for any new features or bug fixes.\n\n## License\n\nThis gem is available as open source under the terms of the [MIT License](https://opensource.org/licenses/MIT).\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/chrono_forge.gemspec",
    "contents": "# frozen_string_literal: true\n\nrequire_relative \"lib/chrono_forge/version\"\n\nGem::Specification.new do |spec|\n  spec.name = \"chrono_forge\"\n  spec.version = ChronoForge::VERSION\n  spec.authors = [\"Stefan Froelich\"]\n  spec.email = [\"sfroelich01@gmail.com\"]\n\n  spec.summary = \"Base fields for the Phlexi libraries\"\n  spec.description = \"Base fields for the Phlexi libraries\"\n  spec.homepage = \"https://github.com/radioactive-labs/chrono_forge\"\n  spec.license = \"MIT\"\n  spec.required_ruby_version = \">= 3.2.2\"\n\n  spec.metadata[\"allowed_push_host\"] = \"https://rubygems.org\"\n\n  spec.metadata[\"homepage_uri\"] = spec.homepage\n  spec.metadata[\"source_code_uri\"] = spec.homepage\n  spec.metadata[\"changelog_uri\"] = spec.homepage\n\n  # Specify which files should be added to the gem when it is released.\n  # The `git ls-files -z` loads the files in the RubyGem that have been added into git.\n  gemspec = File.basename(__FILE__)\n  spec.files = IO.popen(%w[git ls-files -z], chdir: __dir__, err: IO::NULL) do |ls|\n    ls.readlines(\"\\x0\", chomp: true).reject do |f|\n      (f == gemspec) ||\n        f.start_with?(*%w[bin/ test/ spec/ features/ .git .github appveyor Gemfile])\n    end\n  end\n  spec.bindir = \"exe\"\n  spec.executables = spec.files.grep(%r{\\Aexe/}) { |f| File.basename(f) }\n  spec.require_paths = [\"lib\"]\n\n  spec.add_dependency \"activerecord\"\n  spec.add_dependency \"activejob\"\n  spec.add_dependency \"zeitwerk\"\n\n  spec.add_development_dependency \"rake\"\n  spec.add_development_dependency \"minitest\"\n  spec.add_development_dependency \"minitest-reporters\"\n  spec.add_development_dependency \"standard\"\n  # spec.add_development_dependency \"brakeman\"\n  spec.add_development_dependency \"bundle-audit\"\n  spec.add_development_dependency \"appraisal\"\n  spec.add_development_dependency \"combustion\"\n  spec.add_development_dependency \"chaotic_job\"\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/export.rb",
    "contents": "require \"json\"\nrequire \"find\"\n\ndef export_files_to_json(directory, extensions, output_file, exceptions = [])\n  # Convert extensions to lowercase for case-insensitive matching\n  extensions = extensions.map(&:downcase)\n\n  # Array to store file data\n  files_data = []\n\n  # Find all files in directory and subdirectories\n  Find.find(directory) do |path|\n    # Skip if not a file\n    next unless File.file?(path)\n    next if exceptions.any? { |exception| path.include?(exception) }\n\n    # Check if file extension matches any in our list\n    ext = File.extname(path).downcase[1..-1] # Remove the leading dot\n    next unless extensions.include?(ext)\n\n    puts path\n\n    begin\n      # Read file contents\n      contents = File.read(path)\n\n      # Add to our array\n      files_data << {\n        \"path\" => path,\n        \"contents\" => contents\n      }\n    rescue => e\n      puts \"Error reading file #{path}: #{e.message}\"\n    end\n  end\n\n  # Write to JSON file\n  File.write(output_file, JSON.pretty_generate(files_data))\n\n  puts \"Successfully exported #{files_data.length} files to #{output_file}\"\nend\n\n# Example usage (uncomment and modify as needed):\ndirectory = \"/Users/stefan/Documents/plutonium/chrono_forge\"\nexceptions = [\"/.github/\", \"/.vscode/\", \"gemfiles\", \"pkg\", \"node_modules\"]\nextensions = [\"rb\", \"md\", \"yml\", \"yaml\", \"gemspec\"]\noutput_file = \"export.json\"\nexport_files_to_json(directory, extensions, output_file, exceptions)\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge/error_log.rb",
    "contents": "# frozen_string_literal: true\n\n# == Schema Information\n#\n# Table name: chrono_forge_error_logs\n#\n#  id            :integer          not null, primary key\n#  backtrace     :text\n#  context       :json\n#  error_class   :string\n#  error_message :text\n#  created_at    :datetime         not null\n#  updated_at    :datetime         not null\n#  workflow_id   :integer          not null\n#\n# Indexes\n#\n#  index_chrono_forge_error_logs_on_workflow_id  (workflow_id)\n#\n# Foreign Keys\n#\n#  workflow_id  (workflow_id => chrono_forge_workflows.id)\n#\n\nmodule ChronoForge\n  class ErrorLog < ActiveRecord::Base\n    self.table_name = \"chrono_forge_error_logs\"\n\n    belongs_to :workflow\n\n    # Cleanup method\n    def self.cleanup_old_logs(retention_period: 30.days)\n      where(\"created_at < ?\", retention_period.ago).delete_all\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge/execution_log.rb",
    "contents": "# frozen_string_literal: true\n\n# == Schema Information\n#\n# Table name: chrono_forge_execution_logs\n#\n#  id               :integer          not null, primary key\n#  attempts         :integer          default(0), not null\n#  completed_at     :datetime\n#  error_class      :string\n#  error_message    :text\n#  last_executed_at :datetime\n#  metadata         :json\n#  started_at       :datetime\n#  state            :integer          default(\"pending\"), not null\n#  step_name        :string           not null\n#  created_at       :datetime         not null\n#  updated_at       :datetime         not null\n#  workflow_id      :integer          not null\n#\n# Indexes\n#\n#  idx_on_workflow_id_step_name_11bea8586e               (workflow_id,step_name) UNIQUE\n#  index_chrono_forge_execution_logs_on_workflow_id  (workflow_id)\n#\n# Foreign Keys\n#\n#  workflow_id  (workflow_id => chrono_forge_workflows.id)\n#\nmodule ChronoForge\n  class ExecutionLog < ActiveRecord::Base\n    self.table_name = \"chrono_forge_execution_logs\"\n\n    belongs_to :workflow\n\n    enum :state, %i[\n      pending\n      completed\n      failed\n    ]\n\n    # Cleanup method\n    def self.cleanup_old_logs(retention_period: 30.days)\n      where(\"created_at < ?\", retention_period.ago).delete_all\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge/executor/context.rb",
    "contents": "module ChronoForge\n  module Executor\n    class Context\n      class ValidationError < Error; end\n\n      ALLOWED_TYPES = [\n        String,\n        Integer,\n        Float,\n        TrueClass,\n        FalseClass,\n        NilClass,\n        Hash,\n        Array\n      ]\n\n      def initialize(workflow)\n        @workflow = workflow\n        @context = workflow.context || {}\n        @dirty = false\n      end\n\n      def []=(key, value)\n        # Type and size validation\n        validate_value!(value)\n\n        @context[key.to_s] =\n          if value.is_a?(Hash) || value.is_a?(Array)\n            deep_dup(value)\n          else\n            value\n          end\n\n        @dirty = true\n      end\n\n      def [](key)\n        @context[key.to_s]\n      end\n\n      def save!\n        return unless @dirty\n\n        @workflow.update_column(:context, @context)\n        @dirty = false\n      end\n\n      private\n\n      def validate_value!(value)\n        unless ALLOWED_TYPES.any? { |type| value.is_a?(type) }\n          raise ValidationError, \"Unsupported context value type: #{value.inspect}\"\n        end\n\n        # Optional: Add size constraints\n        if value.is_a?(String) && value.size > 64.kilobytes\n          raise ValidationError, \"Context value too large\"\n        end\n      end\n\n      def deep_dup(obj)\n        JSON.parse(JSON.generate(obj))\n      rescue\n        obj.dup\n      end\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge/executor/execution_tracker.rb",
    "contents": "module ChronoForge\n  module Executor\n    class ExecutionTracker\n      def self.track_error(workflow, error)\n        # Create a detailed error log\n        ErrorLog.create!(\n          workflow: workflow,\n          error_class: error.class.name,\n          error_message: error.message,\n          backtrace: error.backtrace.join(\"\\n\"),\n          context: workflow.context\n        )\n      end\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge/executor/lock_strategy.rb",
    "contents": "module ChronoForge\n  module Executor\n    class LongRunningConcurrentExecutionError < Error; end\n\n    class ConcurrentExecutionError < Error; end\n\n    class LockStrategy\n      def self.acquire_lock(job_id, workflow, max_duration:)\n        ActiveRecord::Base.transaction do\n          # Find the workflow with a lock, considering stale locks\n          workflow = workflow.lock!\n\n          # Check for active execution\n          if workflow.locked_at && workflow.locked_at > max_duration.ago\n            raise ConcurrentExecutionError, \"Job currently in progress\"\n          end\n\n          # Atomic update of lock status\n          workflow.update_columns(\n            locked_by: job_id,\n            locked_at: Time.current,\n            state: :running\n          )\n\n          workflow\n        end\n      end\n\n      def self.release_lock(job_id, workflow)\n        workflow = workflow.reload\n        if workflow.locked_by != job_id\n          raise LongRunningConcurrentExecutionError,\n            \"#{self.class}(#{job_id}) executed longer than specified max_duration, \" \\\n            \"allowing another instance(#{workflow.locked_by}) to acquire the lock.\"\n        end\n\n        columns = {locked_at: nil, locked_by: nil}\n        columns[:state] = :idle if workflow.running?\n\n        workflow.update_columns(columns)\n      end\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge/executor/methods/durably_execute.rb",
    "contents": "module ChronoForge\n  module Executor\n    module Methods\n      module DurablyExecute\n        def durably_execute(method, **options)\n          # Create execution log\n          step_name = \"durably_execute$#{method}\"\n          execution_log = ExecutionLog.create_or_find_by!(\n            workflow: @workflow,\n            step_name: step_name\n          ) do |log|\n            log.started_at = Time.current\n          end\n\n          # Return if already completed\n          return execution_log.metadata[\"result\"] if execution_log.completed?\n\n          # Execute with error handling\n          begin\n            # Update execution log with attempt\n            execution_log.update!(\n              attempts: execution_log.attempts + 1,\n              last_executed_at: Time.current\n            )\n\n            # Execute the method\n            result = if method.is_a?(Symbol)\n              send(method)\n            else\n              method.call(@context)\n            end\n\n            # Complete the execution\n            execution_log.update!(\n              state: :completed,\n              completed_at: Time.current,\n              metadata: {result: result}\n            )\n            result\n          rescue HaltExecutionFlow\n            raise\n          rescue => e\n            # Log the error\n            Rails.logger.error { \"Error while durably executing #{method}: #{e.message}\" }\n            self.class::ExecutionTracker.track_error(workflow, e)\n\n            # Optional retry logic\n            if execution_log.attempts < (options[:max_attempts] || 3)\n              # Reschedule with exponential backoff\n              backoff = (2**[execution_log.attempts || 1, 5].min).seconds\n\n              self.class\n                .set(wait: backoff)\n                .perform_later(\n                  @workflow.key,\n                  retry_method: method\n                )\n\n              # Halt current execution\n              halt_execution!\n            else\n              # Max attempts reached\n              execution_log.update!(\n                state: :failed,\n                error_message: e.message,\n                error_class: e.class.name\n              )\n              raise ExecutionFailedError, \"#{step_name} failed after maximum attempts\"\n            end\n          end\n        end\n      end\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge/executor/methods/wait.rb",
    "contents": "module ChronoForge\n  module Executor\n    module Methods\n      module Wait\n        def wait(duration, name, **options)\n          # Create execution log\n          execution_log = ExecutionLog.create_or_find_by!(\n            workflow: @workflow,\n            step_name: \"wait$#{name}\"\n          ) do |log|\n            log.started_at = Time.current\n            log.metadata = {\n              wait_until: duration.from_now\n            }\n          end\n\n          # Return if already completed\n          return if execution_log.completed?\n\n          # Check if wait period has passed\n          if Time.current >= Time.parse(execution_log.metadata[\"wait_until\"])\n            execution_log.update!(\n              attempts: execution_log.attempts + 1,\n              state: :completed,\n              completed_at: Time.current,\n              last_executed_at: Time.current\n            )\n            return\n          end\n\n          execution_log.update!(\n            attempts: execution_log.attempts + 1,\n            last_executed_at: Time.current\n          )\n\n          # Reschedule the job\n          self.class\n            .set(wait: duration)\n            .perform_later(@workflow.key)\n\n          # Halt current execution\n          halt_execution!\n        end\n      end\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge/executor/methods/wait_until.rb",
    "contents": "module ChronoForge\n  module Executor\n    class WaitConditionNotMet < ExecutionFailedError; end\n\n    module Methods\n      module WaitUntil\n        def wait_until(condition, **options)\n          # Default timeout and check interval\n          timeout = options[:timeout] || 10.seconds\n          check_interval = options[:check_interval] || 1.second\n\n          # Find or create execution log\n          step_name = \"wait_until$#{condition}\"\n          execution_log = ExecutionLog.create_or_find_by!(\n            workflow: @workflow,\n            step_name: step_name\n          ) do |log|\n            log.started_at = Time.current\n            log.metadata = {\n              timeout_at: timeout.from_now,\n              check_interval: check_interval,\n              condition: condition.to_s\n            }\n          end\n\n          # Return if already completed\n          if execution_log.completed?\n            return execution_log.metadata[\"result\"]\n          end\n\n          # Evaluate condition\n          begin\n            execution_log.update!(\n              attempts: execution_log.attempts + 1,\n              last_executed_at: Time.current\n            )\n\n            condition_met = if condition.is_a?(Proc)\n              condition.call(@context)\n            elsif condition.is_a?(Symbol)\n              send(condition)\n            else\n              raise ArgumentError, \"Unsupported condition type\"\n            end\n          rescue HaltExecutionFlow\n            raise\n          rescue => e\n            # Log the error\n            Rails.logger.error { \"Error evaluating condition #{condition}: #{e.message}\" }\n            self.class::ExecutionTracker.track_error(workflow, e)\n\n            # Optional retry logic\n            if (options[:retry_on] || []).include?(e.class)\n              # Reschedule with exponential backoff\n              backoff = (2**[execution_log.attempts || 1, 5].min).seconds\n\n              self.class\n                .set(wait: backoff)\n                .perform_later(\n                  @workflow.key\n                )\n\n              # Halt current execution\n              halt_execution!\n            else\n              execution_log.update!(\n                state: :failed,\n                error_message: e.message,\n                error_class: e.class.name\n              )\n              raise ExecutionFailedError, \"#{step_name} failed with an error: #{e.message}\"\n            end\n          end\n\n          # Handle condition met\n          if condition_met\n            execution_log.update!(\n              state: :completed,\n              completed_at: Time.current,\n              metadata: execution_log.metadata.merge(\"result\" => true)\n            )\n            return true\n          end\n\n          # Check for timeout\n          metadata = execution_log.metadata\n          if Time.current > metadata[\"timeout_at\"]\n            execution_log.update!(\n              state: :failed,\n              metadata: metadata.merge(\"result\" => nil)\n            )\n            Rails.logger.warn { \"Timeout reached for condition #{condition}. Condition not met within the timeout period.\" }\n            raise WaitConditionNotMet, \"Condition not met within timeout period\"\n          end\n\n          # Reschedule with delay\n          self.class\n            .set(wait: check_interval)\n            .perform_later(\n              @workflow.key,\n              wait_condition: condition\n            )\n\n          # Halt current execution\n          halt_execution!\n        end\n      end\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge/executor/methods.rb",
    "contents": "module ChronoForge\n  module Executor\n    module Methods\n      include Methods::Wait\n      include Methods::WaitUntil\n      include Methods::DurablyExecute\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge/executor/retry_strategy.rb",
    "contents": "module ChronoForge\n  module Executor\n    class RetryStrategy\n      BACKOFF_STRATEGY = [\n        1.second,   # Initial retry\n        5.seconds,  # Second retry\n        30.seconds, # Third retry\n        2.minutes,  # Fourth retry\n        10.minutes  # Final retry\n      ]\n\n      def self.schedule_retry(workflow, attempt: 0)\n        wait_duration = BACKOFF_STRATEGY[attempt] || BACKOFF_STRATEGY.last\n\n        # Schedule with exponential backoff\n        workflow.job_klass.constantize\n          .set(wait: wait_duration)\n          .perform_later(\n            workflow.key,\n            attempt: attempt + 1\n          )\n      end\n\n      def self.max_attempts\n        BACKOFF_STRATEGY.length\n      end\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge/executor.rb",
    "contents": "module ChronoForge\n  module Executor\n    class Error < StandardError; end\n\n    class ExecutionFailedError < Error; end\n\n    class ExecutionFlowControl < Error; end\n\n    class HaltExecutionFlow < ExecutionFlowControl; end\n\n    include Methods\n\n    def perform(key, attempt: 0, **kwargs)\n      # Prevent excessive retries\n      if attempt >= self.class::RetryStrategy.max_attempts\n        Rails.logger.error { \"Max attempts reached for job #{key}\" }\n        return\n      end\n\n      # Find or create job with comprehensive tracking\n      setup_workflow(key, kwargs)\n\n      begin\n        # Skip if workflow cannot be executed\n        return unless workflow.executable?\n\n        # Acquire lock with advanced concurrency protection\n        self.class::LockStrategy.acquire_lock(job_id, workflow, max_duration: max_duration)\n\n        # Execute core job logic\n        super(**workflow.kwargs.symbolize_keys)\n\n        # Mark as complete\n        complete_workflow!\n      rescue ExecutionFailedError => e\n        Rails.logger.error { \"Execution step failed for #{key}\" }\n        self.class::ExecutionTracker.track_error(workflow, e)\n        workflow.stalled!\n        nil\n      rescue HaltExecutionFlow\n        # Halt execution\n        Rails.logger.debug { \"Execution halted for #{key}\" }\n        nil\n      rescue ConcurrentExecutionError\n        # Graceful handling of concurrent execution\n        Rails.logger.warn { \"Concurrent execution detected for job #{key}\" }\n        nil\n      rescue => e\n        Rails.logger.error { \"An error occurred during execution of #{key}\" }\n        self.class::ExecutionTracker.track_error(workflow, e)\n\n        # Retry if applicable\n        if should_retry?(e, attempt)\n          self.class::RetryStrategy.schedule_retry(workflow, attempt: attempt)\n        else\n          workflow.failed!\n        end\n      ensure\n        context.save!\n        # Always release the lock\n        self.class::LockStrategy.release_lock(job_id, workflow)\n      end\n    end\n\n    private\n\n    def complete_workflow!\n      # Create an execution log for workflow completion\n      execution_log = ExecutionLog.create_or_find_by!(\n        workflow: workflow,\n        step_name: \"$workflow_completion$\"\n      ) do |log|\n        log.started_at = Time.current\n        log.metadata = {\n          workflow_id: workflow.id\n        }\n      end\n\n      begin\n        execution_log.update!(\n          attempts: execution_log.attempts + 1,\n          last_executed_at: Time.current\n        )\n\n        workflow.completed_at = Time.current\n        workflow.completed!\n\n        # Mark execution log as completed\n        execution_log.update!(\n          state: :completed,\n          completed_at: Time.current\n        )\n\n        # Return the execution log for tracking\n        execution_log\n      rescue => e\n        # Log any completion errors\n        execution_log.update!(\n          state: :failed,\n          error_message: e.message,\n          error_class: e.class.name\n        )\n        raise\n      end\n    end\n\n    def setup_workflow(key, kwargs)\n      @workflow = find_workflow(key, kwargs)\n      @context = Context.new(@workflow)\n    end\n\n    def find_workflow(key, kwargs)\n      Workflow.create_or_find_by!(key: key) do |workflow|\n        workflow.job_klass = self.class.to_s\n        workflow.kwargs = kwargs\n        workflow.started_at = Time.current\n      end\n    end\n\n    def should_retry?(error, attempt_count)\n      attempt_count < 3\n    end\n\n    def halt_execution!\n      raise HaltExecutionFlow\n    end\n\n    def workflow\n      @workflow\n    end\n\n    def context\n      @context\n    end\n\n    def max_duration\n      10.minutes\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge/version.rb",
    "contents": "# frozen_string_literal: true\n\nmodule ChronoForge\n  VERSION = \"0.1.0\"\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge/workflow.rb",
    "contents": "# frozen_string_literal: true\n\n# == Schema Information\n#\n# Table name: chrono_forge_workflows\n#\n#  id           :integer          not null, primary key\n#  completed_at :datetime\n#  context      :json             not null\n#  job_klass    :string           not null\n#  key          :string           not null\n#  kwargs       :json             not null\n#  locked_at    :datetime\n#  started_at   :datetime\n#  state        :integer          default(\"idle\"), not null\n#  created_at   :datetime         not null\n#  updated_at   :datetime         not null\n#\n# Indexes\n#\n#  index_chrono_forge_workflows_on_key  (key) UNIQUE\n#\nmodule ChronoForge\n  class Workflow < ActiveRecord::Base\n    self.table_name = \"chrono_forge_workflows\"\n\n    has_many :execution_logs\n    has_many :error_logs\n\n    enum :state, %i[\n      idle\n      running\n      completed\n      failed\n      stalled\n    ]\n\n    # Cleanup method\n    def self.cleanup_old_logs(retention_period: 30.days)\n      where(\"created_at < ?\", retention_period.ago).delete_all\n    end\n\n    # Serialization for metadata\n    serialize :metadata, coder: JSON\n\n    def executable?\n      idle? || running?\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/chrono_forge.rb",
    "contents": "# frozen_string_literal: true\n\nrequire \"zeitwerk\"\nrequire \"active_record\"\nrequire \"active_job\"\n\nmodule Chronoforge\n  Loader = Zeitwerk::Loader.for_gem.tap do |loader|\n    loader.ignore(\"#{__dir__}/generators\")\n    loader.setup\n  end\n\n  class Error < StandardError; end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/generators/chrono_forge/install/install_generator.rb",
    "contents": "# frozen_string_literal: true\n\nrequire \"rails/generators/active_record/migration\"\n\nmodule ChronoForge\n  class InstallGenerator < Rails::Generators::Base\n    include ::ActiveRecord::Generators::Migration\n\n    source_root File.expand_path(\"templates\", __dir__)\n\n    def start\n      install_migrations\n    rescue => err\n      say \"#{err.class}: #{err}\\n#{err.backtrace.join(\"\\n\")}\", :red\n      exit 1\n    end\n\n    private\n\n    def install_migrations\n      migration_template \"install_chrono_forge.rb\", \"install_chrono_forge.rb\"\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/lib/generators/chrono_forge/install/templates/install_chrono_forge.rb",
    "contents": "# frozen_string_literal: true\n\nclass InstallChronoForge < ActiveRecord::Migration[7.1]\n  def change\n    create_table :chrono_forge_workflows do |t|\n      t.string :key, null: false, index: {unique: true}\n      t.string :job_klass, null: false\n\n      if t.respond_to?(:jsonb)\n        t.jsonb :kwargs, null: false, default: {}\n        t.jsonb :options, null: false, default: {}\n        t.jsonb :context, null: false, default: {}\n      else\n        t.json :kwargs, null: false, default: {}\n        t.json :options, null: false, default: {}\n        t.json :context, null: false, default: {}\n      end\n\n      t.integer :state, null: false, default: 0\n      t.string :locked_by\n      t.datetime :locked_at\n\n      t.datetime :started_at\n      t.datetime :completed_at\n\n      t.timestamps\n    end\n\n    create_table :chrono_forge_execution_logs do |t|\n      t.references :workflow, null: false, foreign_key: {to_table: :chrono_forge_workflows}\n      t.string :step_name, null: false\n      t.integer :attempts, null: false, default: 0\n      t.datetime :started_at\n      t.datetime :last_executed_at\n      t.datetime :completed_at\n      if t.respond_to?(:jsonb)\n        t.jsonb :metadata\n      else\n        t.json :metadata\n      end\n      t.integer :state, null: false, default: 0\n      t.string :error_class\n      t.text :error_message\n\n      t.timestamps\n      t.index %i[workflow_id step_name], unique: true\n    end\n\n    create_table :chrono_forge_error_logs do |t|\n      t.references :workflow, null: false, foreign_key: {to_table: :chrono_forge_workflows}\n      t.string :error_class\n      t.text :error_message\n      t.text :backtrace\n      if t.respond_to?(:jsonb)\n        t.jsonb :context\n      else\n        t.json :context\n      end\n\n      t.timestamps\n    end\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/test/chrono_forge_test.rb",
    "contents": "require \"test_helper\"\n\nclass ChronoForgeTest < Minitest::Test\n  include ChaoticJob::Helpers\n\n  def test_version\n    assert ChronoForge::VERSION\n  end\n\n  def test_job_is_durable\n    DurableJob.perform_later(:key)\n    perform_all_jobs\n\n    assert ChronoForge::Workflow.last.completed?\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/test/internal/app/jobs/durable_job.rb",
    "contents": "class DurableJob < ActiveJob::Base\n  prepend ChronoForge::Executor\n\n  def perform\n    # Context can be used to pass and store data between executions\n    context[\"order_id\"] = SecureRandom.hex\n\n    # Wait until payment is confirmed\n    wait_until :payment_confirmed?\n\n    # Wait for potential fraud check\n    wait 1.seconds, :fraud_check_delay\n\n    # Durably execute order processing\n    durably_execute :process_order\n\n    # Final steps\n    complete_order\n  end\n\n  private\n\n  def payment_confirmed?\n    [true, false].sample\n  end\n\n  def process_order\n    context[\"processed_at\"] = Time.current.iso8601\n  end\n\n  def complete_order\n    context[\"completed_at\"] = Time.current.iso8601\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/test/internal/app/models/user.rb",
    "contents": "class User < ActiveRecord::Base\n  validates :name, presence: true\n  validates :email, presence: true\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/test/internal/config/database.yml",
    "contents": "test:\n  adapter:  sqlite3\n  database: db/combustion_test.sqlite\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/test/internal/config/storage.yml",
    "contents": "test:\n  service: Disk\n  root: tmp/storage\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/test/internal/db/migrate/20241217100623_install_chrono_forge.rb",
    "contents": "# The template is our single source of truth.\nrequire File.expand_path(\"../../../../lib/generators/chrono_forge/install/templates/install_chrono_forge.rb\", __dir__)\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/test/internal/db/schema.rb",
    "contents": "# frozen_string_literal: true\n\nActiveRecord::Schema.define do\n  create_table :users, force: true do |t|\n    t.string :name\n    t.string :email\n    t.timestamps null: false\n  end\nend\n"
  },
  {
    "path": "/Users/stefan/Documents/plutonium/chrono_forge/test/test_helper.rb",
    "contents": "require \"chrono_forge\"\n\nrequire \"minitest/autorun\"\nrequire \"minitest/reporters\"\nMinitest::Reporters.use!\n\nrequire \"combustion\"\nCombustion.path = \"test/internal\"\nCombustion.initialize! :active_record, :active_job\n\nrequire \"chaotic_job\"\n"
  }
]